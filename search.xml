<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[How Many Tables(并查集入门)]]></title>
      <url>/How-Many-Tables-%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1213" target="_blank" rel="noopener">HDU-1213 </a></p>
<blockquote>
<p>&emsp;Today is Ignatius’ birthday. He invites a lot of friends. Now it’s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers.<br>&emsp;One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table.<br>&emsp;For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>&emsp;The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks.</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul>
<li><p>intput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">5 1</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure>
</li>
<li><p>output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>并查集入门题。初始化每人单独为一个集合，每次读入A,B就合并A,B所在的集合，每个集合都有一个<strong>代表元素</strong>，集合中的元素都指向代表元素并且只有代表元素指向自己，最后遍历一遍求出答案。</li>
<li>同样的方法也可以求无向图里的连通分支数。</li>
</ul>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRL(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 0xfffffff</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> e = <span class="number">2.718281828459</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Friend[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  tem=x;</span><br><span class="line">    <span class="keyword">while</span>(Friend[tem]!=tem)	<span class="comment">//查找x元素所在集合的代表元素</span></span><br><span class="line">        tem=Friend[tem];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t=x;</span><br><span class="line">    <span class="keyword">while</span>(Friend[t]!=tem)	<span class="comment">//压缩路径</span></span><br><span class="line">    &#123;</span><br><span class="line">        x=Friend[t];</span><br><span class="line">        Friend[t]=tem;</span><br><span class="line">        t=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> test,n,way,a,b,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;test;</span><br><span class="line">    <span class="keyword">while</span>(test--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;way;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">            Friend[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;way; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            a=Find(a),b=Find(b);</span><br><span class="line">            <span class="keyword">if</span>(a!=b)				<span class="comment">//合并两个集合</span></span><br><span class="line">                Friend[a]=Friend[b];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)		<span class="comment">//查找有几个代表元素</span></span><br><span class="line">            <span class="keyword">if</span>(Friend[i]==i)</span><br><span class="line">                ans++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 题解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 并查集，图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[求数列的逆序数]]></title>
      <url>/%E6%B1%82%E6%95%B0%E5%88%97%E7%9A%84%E9%80%86%E5%BA%8F%E6%95%B0/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>&emsp;在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的<strong>逆序数</strong>。</p>
</blockquote>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="暴力出奇迹"><a href="#暴力出奇迹" class="headerlink" title="暴力出奇迹"></a>暴力出奇迹</h2><blockquote>
<ul>
<li>对于每一个数都遍历一遍排在他前面的数，每有一个比他大的数就ans++，时间复杂度为$O(n^2)$，很明显这个算法只能应用于数很少的情况。</li>
</ul>
</blockquote>
<h2 id="归并排序求逆序数"><a href="#归并排序求逆序数" class="headerlink" title="归并排序求逆序数"></a>归并排序求逆序数</h2><blockquote>
<ul>
<li>归并排序中，在每次合并的时候判断一下。<br><img src="/image/逆序数.jpg" alt="数列"></li>
<li>假设数列为9 1 0 5 4，先把它分成两个子序列，9 1 | 0 5 4，使左右分别有序，则有1 9 | 0 4 5，此时进行两个子序列合并。如果a[i]&lt;=a[j],则i++，继续比较，如果a[i]&gt;a[i],则说明a[i]到a[mid]的数都大于a[j],那么ans+=mid-i+1。</li>
</ul>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ll a[<span class="number">500005</span>],tem[<span class="number">500005</span>],ans;       <span class="comment">//a为要求的序列，tem是临时存放的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span>       <span class="comment">//子序列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(high==low)                   <span class="comment">//因为上面那种思路需要子序列有序，当子序列只有一个数时，即认为这个子序列有序</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	divide(low,(low+high)/<span class="number">2</span>);       <span class="comment">//使左边有序</span></span><br><span class="line">	divide((low+high)/<span class="number">2</span>+<span class="number">1</span>,high);    <span class="comment">//使右边有序</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>; </span><br><span class="line">	<span class="keyword">int</span> i=low,j=mid+<span class="number">1</span>,k=low;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)          <span class="comment">//合并</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=mid-i+<span class="number">1</span>;</span><br><span class="line">			tem[k++]=a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		tem[k++]=a[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid) tem[k++]=a[i++];  <span class="comment">//将剩下的存入数组</span></span><br><span class="line">	<span class="keyword">while</span>(j&lt;=high) tem[k++]=a[j++];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> t=low;t&lt;=high;t++) a[t]=tem[t]; <span class="comment">//更新a数组</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用树状数组求逆序数"><a href="#用树状数组求逆序数" class="headerlink" title="用树状数组求逆序数"></a>用树状数组求逆序数</h2><blockquote>
<ul>
<li>未完待续…</li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 排列组合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FATE(二维费用背包问题)]]></title>
      <url>/FATE-%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2159" target="_blank" rel="noopener">hdu-2159</a></p>
<blockquote>
<p>&emsp;最近xhd正在玩一款叫做FATE的游戏，为了得到极品装备，xhd在不停的杀怪做任务。久而久之xhd开始对杀怪产生的厌恶感，但又不得不通过杀怪来升完这最后一级。现在的问题是，xhd升掉最后一级还需n的经验值，xhd还留有m的忍耐度，每杀一个怪xhd会得到相应的经验，并减掉相应的忍耐度。当忍耐度降到0或者0以下时，xhd就不会玩这游戏。xhd还说了他最多只杀s只怪。请问他能升掉这最后一级吗？</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>输入数据有多组，对于每组数据第一行输入n，m，k，s(0 &lt; n,m,k,s &lt; 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 &lt; a,b &lt; 20)；分别表示杀掉一只这种怪xhd会得到的经验值和会减掉的忍耐度。(每种怪都有无数个)</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>输出升完这级还能保留的最大忍耐度，如果无法升完这级输出-1。</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul>
<li><p>intput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10 10 1 10</span><br><span class="line">1 1</span><br><span class="line">10 10 1 9</span><br><span class="line">1 1</span><br><span class="line">9 10 2 10</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">-1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>有两个费用，一个是忍耐度，另一个是杀怪数。</li>
<li>注意这里对经验的理解，它不是第三个费用。</li>
<li>然后用完全背包，最后判断一下最优解即可。</li>
</ul>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRL(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 0xfffffff</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> e = <span class="number">2.718281828459</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>],n,m,k,s,cost[<span class="number">105</span>],valum[<span class="number">105</span>];  <span class="comment">//dp[i][j]:杀i,耐力j时的经验</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;valum[i]&gt;&gt;cost[i];</span><br><span class="line"></span><br><span class="line">        CRL(dp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>; p&lt;=s; p++)				 <span class="comment">//杀怪</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=cost[i]; j&lt;=m; j++)		<span class="comment">//忍耐</span></span><br><span class="line">                    dp[p][j]=max(dp[p][j],dp[p<span class="number">-1</span>][j-cost[i]]+valum[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[s][m]&lt;n)				<span class="comment">//如果消耗完耐力都不能升级</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=m; i++)	<span class="comment">//找能升级，耐力消耗最小的</span></span><br><span class="line">                <span class="keyword">if</span>(dp[s][i]&gt;=n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;m-i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 题解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 背包问题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[xiaoxin juju needs help(排列组合+逆元)]]></title>
      <url>/xiaoxin-juju-needs-help-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88-%E9%80%86%E5%85%83/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5651" target="_blank" rel="noopener">hdu-5651</a></p>
<blockquote>
<p>As we all known, xiaoxin is a brilliant coder. He knew <strong>palindromic</strong> strings when he was only a six grade student at elementry school.</p>
<p>This summer he was working at Tencent as an intern. One day his leader came to ask xiaoxin for help. His leader gave him a string and he wanted xiaoxin to generate palindromic strings for him. Once xiaoxin generates a different palindromic string, his leader will give him a watermelon candy. The problem is how many candies xiaoxin’s leader needs to buy?</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>This problem has multi test cases. First line contains a single integer T(T≤20) which represents the number of test cases.<br>For each test case, there is a single line containing a string S(1≤length(S)≤1,000).</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, print an integer which is the number of watermelon candies xiaoxin’s leader needs to buy after mod 1,000,000,007.</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul>
<li><p>intput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">aa</span><br><span class="line">aabb</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
</li>
<li><p>output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>其实这道题难点不是推出公式，而是求解公式(吐血.jpg)。</li>
<li>设字符串为s,字符串长度为Len,字母i出现次数的二分之一为c[i](取整);</li>
<li>如果有解，就要求出现次数是奇数的字母不超过1个(废话)，然后我们只需要考虑一边的所有情况，另一边跟它一样就能构成回文序列。只考虑一边时，共有Len/2个字符,根据高中学的排列组合可知，所有的排列情况是<script type="math/tex; mode=display">\frac{A_{Len/2}^{Len/2}}{A_{c[1]}^{c[1]}A_{c[2]}^{c[2]}...{A_{c[i]}^{c[i]}}} \Longrightarrow \frac{Len/2!}{c[1]!c[2]!...c[i]!}</script></li>
<li>关键就是如何求解这个公式了，由题目可知，Len/2最大是500，也就是要算500!，很明显要爆精度。因为答案对(1e9+7)取摸，这里引入一个转化：<br>(a$ \times $b)%m $\rightarrow$ (a%m $ \times $ b%m )%m  显然正确,所以我们求阶乘的时候只要边乘边对(1e9+7)取模就不会爆精度。<br>但是 (a $ \div $ b)%m $ \not= $ ((a%m) $ \div $ (b%m))%m,所以我们要用逆元变除法为乘法，就可以边乘边取模。</li>
<li>这道题我是用的拓展欧几里德算法求逆元，不知道的可以看我的另一篇博客<a href="http://x-armin.com/数论笔记本/">数论笔记本</a></li>
</ul>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRL(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 0xfffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 6</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll  <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span>	<span class="comment">//求阶乘 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ll ans=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            ans=(ans*i)%mod;		<span class="comment">//边乘边取模 </span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>		<span class="comment">//拓展欧几里德算法，求出的x,即为a%b下a的逆元 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r=exgcd(b,a%b);</span><br><span class="line">    <span class="keyword">int</span> c=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=c-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans;</span><br><span class="line">    <span class="keyword">int</span> book[<span class="number">26</span>],n,Flag=<span class="number">0</span>,Len;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">1005</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        CRL(book);</span><br><span class="line">        Flag=<span class="number">0</span>;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        Len=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;Len; i++)</span><br><span class="line">            book[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(book[i]&amp;<span class="number">1</span>)</span><br><span class="line">                Flag++;</span><br><span class="line">        <span class="keyword">if</span>(Flag&gt;<span class="number">1</span>)		<span class="comment">//如果出现次数为奇数的字母超过1,无解 </span></span><br><span class="line">            ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans=fac(Len/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span>(book[i]&gt;<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    exgcd(fac(book[i]/<span class="number">2</span>),mod);</span><br><span class="line">                    x=x&lt;<span class="number">0</span>? x+mod:x;			<span class="comment">//x小于0的话要转换成正数 </span></span><br><span class="line">                    ans=ans*x%mod;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 题解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LCP Array(排列组合)]]></title>
      <url>/LCP-Array-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5635" target="_blank" rel="noopener">hdu-5635</a></p>
<blockquote>
<p>Peter has a string $s=s_1s_2…s_n$, let $suff_i=s_is_{i+1}…s_n$ be the suffix start with $i^{th}$ character of $s$. Peter knows the <strong>lcp</strong> (longest common prefix) of each two adjacent suffixes which denotes as $a_i=lcp(suff_i,suff_{i+1})(1≤i&lt;n)$.</p>
<p>Given the lcp array, Peter wants to know how many strings containing lowercase English letters only will satisfy the lcp array. The answer may be too large, just print it modulo $10^9+7$.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>There are multiple test cases. The first line of input contains an integer T indicating the number of test cases. For each test case:</p>
<p>The first line contains an integer n ($2≤n≤10^5$) — the length of the string. The second line contains n−1 integers: $a_1,a_2,…,a_{n−1} (0≤a_i≤n)$.</p>
<p>The sum of values of n in all test cases doesn’t exceed $10^6$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case output one integer denoting the answer. The answer must be printed modulo $10^9+7$.</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul>
<li><p>intput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">0 0</span><br><span class="line">4</span><br><span class="line">3 2 1</span><br><span class="line">3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16250</span><br><span class="line">26</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li><strong>有解的条件</strong>：以样例2为例:$lcp_1=3 \Rightarrow s_1=s_2,s_2=s_3,s_3=s_4$,要有解显然$lcp_i=lcp_{i-1}-1$一定成立，而且$lcp_{n-1}$不可能大于1,也就是说如果$lcp_i$=n,那么$lcp_i$到$lcp_{i+n}$的值一定是n到1递减。</li>
<li><strong>计算有解时的答案</strong>：显然当$lcp_i$=n(n&gt;0)时，$s_i$到$s_{i+n}$都为同一个字母，如果$lcp_i$=0,则$s_i$和$s_{i+1}$为不同字母，所以当前一种字母确定时，后一种字母就有25种可能。</li>
<li>所以如果有解，lcp数组中0的个数为n,答案就是$26 \times 25^n$。<del>我也是在草稿本上先找到规律AC了才推出原理的</del></li>
</ul>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRL(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 0xfffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 100000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,len,lcp[M],Flag=<span class="number">0</span>;</span><br><span class="line">    ll ans;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        Flag=<span class="number">0</span>;</span><br><span class="line">        ans=<span class="number">26</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;lcp[i]);</span><br><span class="line">            <span class="keyword">if</span>(lcp[i]+<span class="number">1</span>!=lcp[i<span class="number">-1</span>]&amp;&amp;lcp[i<span class="number">-1</span>]&gt;<span class="number">0</span>)  <span class="comment">//如果不是前比后多一且前一个不为0</span></span><br><span class="line">                Flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(lcp[i]==<span class="number">0</span>)</span><br><span class="line">                ans=(ans*<span class="number">25</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Flag||lcp[len<span class="number">-1</span>]&gt;<span class="number">1</span>)  <span class="comment">//lcp数组末尾一定是0或1</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 题解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 排列组合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一个人的旅行(Dijkstra算法)]]></title>
      <url>/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%97%85%E8%A1%8C-%E6%9C%80%E7%9F%AD%E8%B7%AFDijkstra%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2066" target="_blank" rel="noopener">hdu-2066</a></p>
<blockquote>
<p>&emsp;虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；<br>接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=&lt;(a,b)&lt;=1000;a,b 之间可能有多条路)<br>接着的第T+1行有S个数，表示和草儿家相连的城市；<br>接着的第T+2行有D个数，表示草儿想去地方。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>输出草儿能去某个喜欢的城市的最短时间。</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul>
<li><p>intput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">6 2 3</span><br><span class="line">1 3 5</span><br><span class="line">1 4 7</span><br><span class="line">2 8 12</span><br><span class="line">3 8 4</span><br><span class="line">4 9 12</span><br><span class="line">9 10 2</span><br><span class="line">1 2</span><br><span class="line">8 9 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>一读完题就开始敲Floyd，然后没有意外地T了。</li>
<li><del>经过大佬的一番点拨，</del>我们把草儿家看成一个节点0，邻近的城市和草儿家的距离为0，这样就转换成了最单纯的单源最短路问题。</li>
</ul>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRL(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 99999</span></span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> Distance[<span class="number">1005</span>],<span class="built_in">map</span>[<span class="number">1005</span>][<span class="number">1005</span>],m,n,MaxNode;<span class="comment">//	Distance:源点到点i的距离	MaxNode:最大的节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstar</span><span class="params">(<span class="keyword">int</span> v0)</span>	<span class="comment">//v0为源点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CRL(visit);</span><br><span class="line">    visit[v1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=MaxNode; i++)</span><br><span class="line">        Distance[i]=<span class="built_in">map</span>[v1][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>,t=<span class="number">1</span>,v,w,Min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始主循环，每次求得V0到某个V顶点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span>( v=<span class="number">1</span>; v&lt;=MaxNode; v++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Min=MAX;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">1</span>; w&lt;=MaxNode; w++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[w]&amp;&amp;Distance[w]&lt;Min )</span><br><span class="line">            &#123;</span><br><span class="line">                k=w;</span><br><span class="line">                Min=Distance[w];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[k]=<span class="number">1</span>;	<span class="comment">// 将目前找到的最近的顶点置1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修正当前最短路径及距离</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>; w&lt;=MaxNode; w++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果经过v顶点的路径比现在这条路径的长度短就修正</span></span><br><span class="line">            <span class="keyword">if</span>( !visit[w] &amp;&amp; (Min+<span class="built_in">map</span>[k][w]&lt;Distance[w]) )</span><br><span class="line">                Distance[w]=Min+<span class="built_in">map</span>[k][w];	<span class="comment">// 修改当前路径长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span>		<span class="comment">//建图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,way;</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">map</span>,<span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="built_in">map</span>));	</span><br><span class="line">    <span class="comment">//把map数组全部置为无穷大，准确来说现在map中每个元素在内存中为00000001000000010000000100000001 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;way);</span><br><span class="line">        MaxNode=MaxNode&gt;x?MaxNode:x;</span><br><span class="line">        MaxNode=MaxNode&gt;y?MaxNode:y;</span><br><span class="line">        <span class="keyword">if</span>(way&lt;<span class="built_in">map</span>[x][y])</span><br><span class="line">            <span class="built_in">map</span>[x][y]=<span class="built_in">map</span>[y][x]=way;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="built_in">map</span>[<span class="number">0</span>][x]=<span class="built_in">map</span>[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,ans=<span class="number">99999</span>,want;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&gt;&gt;T)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">99999</span>;</span><br><span class="line">        create();</span><br><span class="line">        Dijkstra(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;T; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;want;</span><br><span class="line">            ans=min(ans,Distance[want]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 题解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ACboy needs your help(分组背包)]]></title>
      <url>/ACboy-needs-your-help-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1712" target="_blank" rel="noopener">hdu-1712</a></p>
<blockquote>
<p>ACboy has N courses this term, and he plans to spend at most M days on study.Of course,the profit he will gain from different course depending on the days he spend on it.How to arrange the M days for the N courses to maximize the profit?</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input consists of multiple data sets. A data set starts with a line containing two positive integers N and M, N is the number of courses, M is the days ACboy has.<br>Next follow a matrix A[i][j], (1&lt;=i&lt;=N&lt;=100,1&lt;=j&lt;=M&lt;=100).A[i][j] indicates if ACboy spend j days on ith course he will get profit of value A[i][j].<br>N = 0 and M = 0 ends the input.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each data set, your program should output a line which contains the number of the max profit ACboy will gain.</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul>
<li><p>intput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 2</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br><span class="line">3 2 1</span><br><span class="line">3 2 1</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>这是一个典型的分组背包问题，我们可以转换成01背包求解。</li>
<li>核心代码</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=V;k++)	<span class="comment">//转01背包，注意三重循环顺序</span></span><br><span class="line">       <span class="keyword">if</span>(j&gt;=k)</span><br><span class="line">        dp[j]=max(dp[j],dp[j-k]+<span class="built_in">map</span>[i][k]);</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 题解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 背包问题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cow Contest(floyd))]]></title>
      <url>/Cow-Contest-floyd/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>传送门：<a href="http://poj.org/problem?id=3660" target="_blank" rel="noopener">poj-3660</a></p>
<blockquote>
<p>N (1 ≤ N ≤ 100) cows, conveniently numbered 1..N, are participating in a programming contest. As we all know, some cows code better than others. Each cow has a certain constant skill rating that is unique among the competitors.</p>
<p>The contest is conducted in several head-to-head rounds, each between two cows. If cow A has a greater skill level than cow B (1 ≤ A ≤ N; 1 ≤ B ≤ N; A ≠ B), then cow A will always beat cow B.</p>
<p>Farmer John is trying to rank the cows by skill level. Given a list the results of M (1 ≤ M ≤ 4,500) two-cow rounds, determine the number of cows whose ranks can be precisely determined from the results. It is guaranteed that the results of the rounds will not be contradictory.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<ul>
<li>Line 1: Two space-separated integers: N and M</li>
<li>Lines 2..M+1: Each line contains two space-separated integers that describe the competitors and results (the first integer, A, is the winner) of a single round of competition: A and B.</li>
</ul>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Line 1: A single integer representing the number of cows whose ranks can be determined.</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul>
<li><p>intput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">4 3</span><br><span class="line">4 2</span><br><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure>
</li>
<li><p>output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>把比赛看成是一个有向图，问题其实就转化成求了求有多少个顶点和其他所有顶点都连通。</li>
<li>形象地说就是当一头牛胜负加起来为n-1时，也就是和其他的牛都比赛过(包括间接的)就能确定它的名次。</li>
</ul>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRL(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 0xfffffff</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">105</span>][<span class="number">105</span>],win[<span class="number">105</span>],defeat[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,w,a,b,ans;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; w)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        CRL(<span class="built_in">map</span>);</span><br><span class="line">        CRL(win);</span><br><span class="line">        CRL(defeat);</span><br><span class="line">        <span class="keyword">while</span>(w--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>[a][b])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>[a][b]=<span class="number">1</span>;</span><br><span class="line">                win[a]++;</span><br><span class="line">                defeat[b]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">map</span>[j][k]&amp;&amp;<span class="built_in">map</span>[k][i]&amp;&amp;!<span class="built_in">map</span>[j][i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">map</span>[j][i]=<span class="number">1</span>;</span><br><span class="line">                        win[j]++;</span><br><span class="line">                        defeat[i]++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">if</span>(win[i]+defeat[i]+<span class="number">1</span>==n)</span><br><span class="line">                ans++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 题解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数论笔记本]]></title>
      <url>/%E6%95%B0%E8%AE%BA%E7%AC%94%E8%AE%B0%E6%9C%AC/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>数论是个好东西。</p>
<a id="more"></a>
<hr>
<h1 id="欧几里德算法-gcd"><a href="#欧几里德算法-gcd" class="headerlink" title="欧几里德算法(gcd)"></a>欧几里德算法(gcd)</h1><blockquote>
<ul>
<li>欧几里德算法又称辗转相除法，用于计算两个正整数a，b的最大公约数。</li>
</ul>
</blockquote>
<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><blockquote>
<ul>
<li>$gcd(a,b)=gcd(b,a$  $mod$ $b)$ </li>
<li>特别的：$gcd(a,0)=a$</li>
</ul>
</blockquote>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><h3 id="充分性"><a href="#充分性" class="headerlink" title="充分性"></a>充分性</h3><blockquote>
<p>设c为a,b的公约数<br>$\because a|c$，$b|c&emsp;&emsp;&emsp;$&emsp;（|：整除）<br>又$\because a=kb+(a$  $mod$ $b),$即$a$  $mod$ $b = a-kb$<br>$\therefore (a$  $mod$ $b) | c$</p>
</blockquote>
<h3 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h3><blockquote>
<p>设$c$为$b$，$a$  $mod$ $b$的公约数<br>$\because b|c,&emsp;(a$  $mod$ $b)|c$<br>又$\because a=kb+(a$  $mod$ $b)$<br>$\therefore a|c$</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">　　        <span class="keyword">return</span> a;</span><br><span class="line">       <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="扩展欧几里德算法"><a href="#扩展欧几里德算法" class="headerlink" title="扩展欧几里德算法"></a>扩展欧几里德算法</h1><blockquote>
<ul>
<li>扩展欧几里德算法是用来在已知a, b求解一组x，y，使它们满足等式：$ ax+by = gcd(a, b)$（解一定存在，根据数论中的相关定理）。扩展欧几里德常用在求解模线性方程及方程组中。</li>
</ul>
</blockquote>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>因为不好描述，所以先给出代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>		<span class="comment">//拓展欧几里德算法，求出的x,即为a%b下a的逆元 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r=exgcd(b,a%b);</span><br><span class="line">    <span class="keyword">int</span> c=x;				<span class="comment">//c只是为了储存x的值</span></span><br><span class="line">    x=y;</span><br><span class="line">    y=c-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h2><blockquote>
<p>递归之后，$ a’=b ,&emsp; b’=a \% b = a-a/b \times b $ （这里的/为计算机里的除法）<br>$a’x+b’y=gcd(a,b)$<br>代入化简$\Rightarrow ay+b(x-a/b \times y) = gcd(a,b) $<br>又$\because ax+by = gcd(a,b)$<br>$\therefore x=y ,&emsp;y=x-a/b \times y$<br>最后的$x,y$即为答案。<br>假设d=gcd(a,b),则x，y所有解：<br>$ x=x+(b/d)t$，$y=y-(a/d)t$;&emsp;其中t为任意常整数</p>
</blockquote>
<hr>
<h1 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h1><blockquote>
<ul>
<li>若$ ax \equiv 1$  $mod$ $m$, 则称a关于1模m的乘法逆元为x。也可表示为$ax \equiv 1(mod$ $m$)。</li>
<li>如果$a,m$不互质，则无解。如果$m$为质数，则从1到$m-1$的任意数都与$m$互质，即在1到$m-1$之间都恰好有一个关于模$m$的乘法逆元。</li>
</ul>
</blockquote>
<h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><h3 id="费马小定理求逆元。"><a href="#费马小定理求逆元。" class="headerlink" title="费马小定理求逆元。"></a>费马小定理求逆元。</h3><blockquote>
<ul>
<li>费马小定理：$a^{m-1} \equiv 1(mod$ $m$)  (m为素数)</li>
<li>变形得: $a \cdot a^{m-2} \equiv 1(mod$ $m$)</li>
<li>故$a^{m-2}$为a在模m下的逆元。($a^{m-2}$用快速幂求解即可)</li>
<li><strong>注意</strong>：$m$必须是质数，且$a,m$互质。(ACM的题一般都是模($10^9+7$),所以基本上都能用)</li>
</ul>
</blockquote>
<h3 id="扩展欧几里德算法求逆元"><a href="#扩展欧几里德算法求逆元" class="headerlink" title="扩展欧几里德算法求逆元"></a>扩展欧几里德算法求逆元</h3><blockquote>
<ul>
<li>扩展欧几里德算法:$ ax+by = gcd(a, b) $</li>
<li>令$b=m$  ,由于$a,m$互质，所以$gcd(a,m)$=1，即$ ax+my = 1 $，两边同时模m，得$ax \equiv 1(mod$ $m$)</li>
<li>这样解出来的$x$就是$a$在模$m$下的逆元。</li>
<li>同样，也要求$m$必须是质数，且$a,m$互质。</li>
</ul>
</blockquote>
<h3 id="欧拉定理求逆元"><a href="#欧拉定理求逆元" class="headerlink" title="欧拉定理求逆元"></a>欧拉定理求逆元</h3><blockquote>
<ul>
<li>欧拉定理：$a^{ \varphi (m)} \equiv 1(mod$ $m$)&emsp;&emsp;($\varphi (m)$是小于m且与m互质的数的个数。)</li>
<li>变形得: $a \cdot a^{ \varphi (m)-1} \equiv 1(mod$ $m$)</li>
<li>故$ a^{ \varphi (m)-1} $为a在模m下的逆元。($a^{ \varphi (m)-1}$用快速幂求解即可)</li>
<li>欧拉定理实际上是费马小定理的推广。</li>
</ul>
</blockquote>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote>
<ul>
<li>有时候在求$({a \over b})\%m$时,可能由于b过大而丢失精度，这时就可以求出b的逆元来变除为乘，具体如下。</li>
<li>设$x$为$b$模$m$的逆元。</li>
<li>${({a \over b})\%m} \Rightarrow {({a \over b})\times 1 \times\%m} \Rightarrow {({a \over b})\times {b \cdot x} \times\%m} \Rightarrow a \cdot x\%m$</li>
</ul>
</blockquote>
<hr>
<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><blockquote>
<ul>
<li>快速幂可以大大减少运算时循环的次数。</li>
</ul>
</blockquote>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><blockquote>
<script type="math/tex; mode=display">
a^n=
\begin{cases}
  ({a^2})^{n \over 2} &\mbox{n为偶数}\\
  a \cdot ({a^2})^{n \over 2} &\mbox{n为奇数}
  \end{cases}</script><ul>
<li>上述变换显然正确。</li>
</ul>
</blockquote>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)        </span><br><span class="line">            ans*=x;  </span><br><span class="line">        x*=x;  </span><br><span class="line">        n/=<span class="number">2</span> ;      </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果题目要求对m取模，则<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    a%=m;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=(ans*a)%m;</span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">        a=(a*a)%m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="斯特林公式"><a href="#斯特林公式" class="headerlink" title="斯特林公式"></a>斯特林公式</h1><blockquote>
<ul>
<li>斯特林公式是一条用来取n的阶乘的近似值的数学公式。一般来说，当n很大的时候，n阶乘的计算量十分大，所以斯特林公式十分好用，而且，即使在n很小的时候，斯特林公式的取值已经十分准确。</li>
</ul>
</blockquote>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><blockquote>
<font size="5">$$n!\approx\sqrt{2\pi n}(\frac{n}{e})^n$$</font>

</blockquote>
<h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><blockquote>
<ul>
<li>求$n!$在十进制下的位数，暴力肯定不行，我们直接用斯特林公式求出$n!$的近似值，再求以10为底近似值的对数 +1(求其他进制下的位数类似，修改底数即可)。</li>
</ul>
</blockquote>
<h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><blockquote>
<ul>
<li>在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。</li>
</ul>
</blockquote>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><blockquote>
<ul>
<li>如果被计数的事物有A、B、C三类，那么：<script type="math/tex; mode=display">A∪B∪C = A+B+C - A∩B - B∩C - C∩A + A∩B∩C</script></li>
<li>例如求给出一个数n，求1到$n$中，有多少个数不是2，5，11，13的倍数。$A,B,C,D$分别是$n/2,n/5,n/11,n/13$。</li>
</ul>
</blockquote>
<hr>
<p>未完待续…</p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多重背包问题]]></title>
      <url>/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p> 有n种物品和一个容积为V的背包，第i种物品有amount[i]个，体积cost[i]和价值valum[i]，问如何选取物品使得放入背包的物品价值之和最大。</p>
</blockquote>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>跟完全背包问题类似，这里就直接给出基本算法的状态转移方程<script type="math/tex; mode=display">dp[i][j]=Max\{dp[i-1][j-k \times cost[i] + k \times  valum[i]\}</script><script type="math/tex; mode=display">(0\leq k \leq amount[i]  且  0\leq k \times cost[i] \leq V)</script></li>
<li>时间复杂度:O($V \times {\sum_{i=1}^N{amount[i]}}$)，空间复杂度:O(NV)。</li>
</ul>
</blockquote>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><blockquote>
<ul>
<li>amount[i]==1时，当01背包处理。</li>
<li>amount[i]$ \times $cost&gt;=V时，当完全背包处理。</li>
<li>amount[i]$ \geq $1时，采用二进制拆分，从而转换成01背包求解，具体如下：<br>&emsp;在上面的状态转移方程中，我们让k从1$ \to $amount[i]来实现拿不同的个数，从而转换成01背包问题，但我们可以发现，我们只要将amount[i]拆分成几个数，就可以用他们组合成小于amount[i]的任何数。例如:amount[i]=11,11的二进制为1011，把11拆成100(4)、0010(2)、0001(1)、4(11-4-2-1),这样就可以用4、2、1、4来组合成11以内所有的整数，这样放第这种物品时本来放11次，现在只要放4次，虽然仍然有重复，但也实现了优化。</li>
</ul>
</blockquote>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><blockquote>
<ul>
<li>如果题目没有要求必须装满，那么我们只要将dp数组全部置为0即可。</li>
<li>如果必须装满，我们就将dp[0]初始化为0，其他初始化为$-\infty$。</li>
</ul>
</blockquote>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRL(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 100000000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V,dp[<span class="number">120002</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> valum)</span>		<span class="comment">//01背包问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=V;i&gt;=cost;i--)</span><br><span class="line">		dp[i]=max(dp[i],dp[i-cost]+valum);</span><br><span class="line">	<span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePack</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> valum)</span>		<span class="comment">//完全背包问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=cost;i&lt;=V;i++)</span><br><span class="line">		dp[i]=max(dp[i],dp[i-cost]+valum);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MultiplePack</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> valum,<span class="keyword">int</span> amount)</span>	<span class="comment">//多重背包问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cost*amount&gt;=V)</span><br><span class="line">		CompletePack(cost,valum);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(k&lt;amount)</span><br><span class="line">		&#123;</span><br><span class="line">			ZeroOnePack(cost*k,valum*k);</span><br><span class="line">			amount-=k;</span><br><span class="line">			k=k&lt;&lt;<span class="number">1</span>; 	<span class="comment">//k*=2</span></span><br><span class="line">		&#125;</span><br><span class="line">		ZeroOnePack(cost*amount,valum*amount);</span><br><span class="line">	 &#125;</span><br><span class="line">	<span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,cost[<span class="number">1000</span>],valum[<span class="number">1000</span>],amount[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;V)</span><br><span class="line">	&#123;</span><br><span class="line">		CRL(dp);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;cost[i]&gt;&gt;valum[i]&gt;&gt;amount[i];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			MultiplePack(cost[i],valum[i],amount[i]);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dp[V]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><blockquote>
<ul>
<li>换一种问法而已：<a href="http://poj.org/problem?id=1014" target="_blank" rel="noopener">poj 1014</a></li>
</ul>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《背包九讲》</p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 背包问题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[完全背包问题]]></title>
      <url>/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p> 有n种物品和一个容积为V的背包，每种物品i都有无限个，都有体积cost[i]和价值valum[i]，问如何选取物品使得放入背包的物品价值之和最大。</p>
</blockquote>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>完全背包和01背包很像，我们首先想到的应该是每种物品在拿0~n个中选max价值的，我们依旧用dp[i][j]来储存将前i种物品放入体积为j的背包中物品价值之和最大值，那么状态转移方程便是在放得下的情况下<script type="math/tex; mode=display">dp[i][j]=Max\{dp[i-1][j-k \times cost[i] + k \times  valum[i]\}</script><script type="math/tex; mode=display">(0\leq k \times cost[i] \leq V)</script></li>
<li>这样最后求出来的dp[n][V]就是最后答案。</li>
<li>时间复杂度:O($V \times {\sum_{i=1}^N{V \over {c[i]}}}$)，空间复杂度:O(NV)。</li>
</ul>
</blockquote>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><blockquote>
<ul>
<li>在01背包问题里面，我们逆序遍历V$(j:V \to 0)$是为了保证dp[j-cost[i]]始终是i-1物品推出的，从而保证每种物品只用一次。而完全背包问题里面我们就可以正序遍历，这样就可以在一次遍历dp[V]中考虑第i种物品的所有拿法。</li>
<li><p>核心代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	  <span class="keyword">for</span>(<span class="keyword">int</span> j=Time[i];j&lt;=t;j++)</span><br><span class="line">	    dp[j]=max(dp[j],dp[j-Time[i]]+valum[i]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>优化后时间复杂度为O(NV)，空间复杂度为O(N)。</p>
</li>
</ul>
</blockquote>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><blockquote>
<ul>
<li>如果题目没有要求必须装满，那么我们只要将dp数组全部置为0即可。</li>
<li>如果必须装满，我们就将dp[0]初始化为0，其他初始化为$-\infty$。</li>
</ul>
</blockquote>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><blockquote>
<ul>
<li>板子题：<a href="https://www.luogu.org/problemnew/show/P1616" target="_blank" rel="noopener">洛谷1616</a></li>
<li>换一种问法：<a href="http://poj.org/problem?id=1014" target="_blank" rel="noopener">poj 1014</a></li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 背包问题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01背包问题]]></title>
      <url>/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p> 有n个物品和一个容积为V的背包，每个物品i都有体积cost[i]和价值valum[i]，问如何选取物品使得放入背包的物品价值之和最大。</p>
</blockquote>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>01背包的特点就是每种物品都只有一个，所以每个物品只有拿和不拿两种状态。</li>
<li>我们用dp[i][j]来储存将前i件物品放入体积为j的背包中物品价值之和最大值，那么状态转移方程便是在放得下的情况下<script type="math/tex; mode=display">
dp[i][j]=Max
\begin{cases}
dp[i-1][j] &\mbox{不拿第i个，状态跟i-1一样}\\
dp[i-1][j-cost[i]]+valum[i] &\mbox{拿第i个，那么就把前cost[i]体积的物品拿走再放}
\end{cases}</script></li>
</ul>
<script type="math/tex; mode=display">(j:0 \to V,i:0 \to n)</script><ul>
<li>这样最后求出来的dp[n][V]就是最后答案。</li>
</ul>
</blockquote>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><blockquote>
<ul>
<li>上面的时间复杂度是O(NV)已经无法再优化了,而空间复杂度可以优化到O(N)：我们用二维数组无非是为了保证状态转移方程里的dp[i-1][j-cost[i]]是上一个物品推出来的，如果我们直接改成dp[j]=max(dp[j],dp[j-cost[i]]+valum[i])的话，在$(j:0 \to V)$过程进行到后面的时候,dp[j-cost]有可能是已经在前面就放了i物品的状态，此时再+valum<a href="放i物品">i</a>就不符合每种物品都只有一个的题意了。</li>
<li>实际上。如果我们在遍历j的时候，采用逆序，即$(j:V \to 0)$，就可以保证dp[j-cost[i]]始终是i-1物品推出的。</li>
<li>核心代码如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	  <span class="keyword">for</span>(<span class="keyword">int</span> j=t;j&gt;=cost[i];j--)</span><br><span class="line">	    dp[j]=max(dp[j],dp[j-cost[i]]+valum[i]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><blockquote>
<ul>
<li>如果题目没有要求必须装满，那么我们只要将dp数组全部置为0即可。</li>
<li>如果必须装满，我们就将dp[0]初始化为0，其他初始化为$-\infty$，$(j:V \to 0)$时每次判断dp[j-cost]是否&gt;=0，是的话就进行状态转移。(自行体会，逃.jpg)</li>
</ul>
</blockquote>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><blockquote>
<ul>
<li>板子题：<a href="https://www.luogu.org/problemnew/show/P1048" target="_blank" rel="noopener">洛谷1048</a></li>
<li>变式：<a href="https://www.luogu.org/problemnew/show/P1164" target="_blank" rel="noopener">洛谷1164</a></li>
<li>变式：<a href="https://www.nowcoder.com/acm/contest/74/B" target="_blank" rel="noopener">2018年全国多校算法寒假训练营练习比赛(第二场) problem B</a>（需要一个微妙的预处理）</li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 背包问题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小牛vs小客(巴什博弈变形)]]></title>
      <url>/%E5%B0%8F%E7%89%9Bvs%E5%B0%8F%E5%AE%A2-%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88%E5%8F%98%E5%BD%A2/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p><a href="https://www.nowcoder.net/acm/contest/75/D" target="_blank" rel="noopener">题目链接</a></p>
<blockquote>
<p>小牛和小客玩石子游戏，他们用n个石子围成一圈，小牛和小客分别从其中取石子，谁先取完谁胜，每次可以从一圈中取一个或者相邻两个，每次都是小牛先取，请输出胜利者的名字。（1 2 3 4 取走 2 13 不算相邻）</p>
</blockquote>
<a id="more"></a>
<h2 id="Intput"><a href="#Intput" class="headerlink" title="Intput"></a>Intput</h2><blockquote>
<p>输入包括多组测试数据<br>每组测试数据一个n（1≤n≤10^9）</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>每组用一行输出胜利者的名字（小牛获胜输出XiaoNiu，小客获胜输出XiaoKe）</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul>
<li><p>intput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
</li>
<li><p>output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XiaoNiu</span><br><span class="line">XiaoKe</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>当n&lt;=2时，毫无疑问是先手获胜。</li>
<li>当n&gt;2时，先手拿了之后，石子形状就可以看成一条线，后手可以选择拿1个或2个，使得剩下的石子是对称的，然后无论先手怎样拿，后手总能在对称位置拿到石子，最后一定是后手赢。</li>
</ul>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;x)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">2</span>)</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">"XiaoNiu\n"</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">"XiaoKe\n"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 题解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博弈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[不凡的夫夫(斯特灵公式)]]></title>
      <url>/%E4%B8%8D%E5%87%A1%E7%9A%84%E5%A4%AB%E5%A4%AB-%E6%96%AF%E7%89%B9%E7%81%B5%E5%85%AC%E5%BC%8F/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p><a href="https://www.nowcoder.net/acm/contest/75/A" target="_blank" rel="noopener">题目链接</a></p>
<blockquote>
<p>夫夫有一天对一个数有多少位数感兴趣，但是他又不想跟凡夫俗子一样，所以他想知道给一个整数n，求n！的在8进制下的位数是多少位。</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>第一行是一个整数t(0&lt;t&lt;=1000000)(表示t组数据)<br>接下来t行，每一行有一个整数n(0&lt;=n&lt;=10000000)</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>输出n！在8进制下的位数。</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul>
<li><p>intput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
</li>
<li><p>output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>看到n的值最大是1e7就知道不能暴力出奇迹，而求n!的位数，就很自然想到要用斯特林公式:<br><font size="5">$n!\approx\sqrt{2\pi n}(\frac{n}{e})^n$</font></li>
<li>虽然斯特林公式只是求阶乘的近似值，但即使在n很小的时候，斯特林公式的取值已经十分准确。</li>
<li>再求以8为底近似值的对数 +1(求其他进制下的位数类似，修改底数即可)。</li>
<li>注意:C语言中不支持任意底数的求对数运算，我们小小的转换一下$\log_x y=\frac{lgy}{lgx}$</li>
</ul>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> e = <span class="number">2.718281828459</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);    </span><br><span class="line">	<span class="keyword">while</span>(t--)    </span><br><span class="line">	&#123;        </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)	<span class="comment">//注意特判 </span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">		<span class="keyword">else</span>        </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(<span class="keyword">int</span>)((<span class="built_in">log</span>(<span class="number">2.0</span>*Pi*n)/(<span class="built_in">log</span>(<span class="number">8</span>))/<span class="number">2.0</span> + n*<span class="built_in">log</span>(n/e)/<span class="built_in">log</span>(<span class="number">8</span>))+<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 题解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2 5 11 13的倍数(容斥原理)]]></title>
      <url>/2-5-11-13%E7%9A%84%E5%80%8D%E6%95%B0-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p><a href="https://www.nowcoder.net/acm/contest/75/G" target="_blank" rel="noopener">题目链接</a></p>
<blockquote>
<p>给出一个数n，求1到n中，有多少个数不是2 5 11 13的倍数。</p>
</blockquote>
<a id="more"></a>
<h2 id="Intput"><a href="#Intput" class="headerlink" title="Intput"></a>Intput</h2><blockquote>
<p>本题有多组输入<br>每行一个数n，1&lt;=n&lt;=10^18.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>每行输出输出不是2 5 11 13的倍数的数共有多少。</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul>
<li><p>intput</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>
</li>
<li><p>output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<ul>
<li>遍历一遍感觉是很快了，时间复杂度O(n)，但还是会超时，其实这道题可以达到O(1)。</li>
<li>我们反过来思考，用总数减去倍数的个数，先不考虑公倍数的问题，再减去公倍数的个数。</li>
<li>假设有三个集合，那么<br> A∪B∪C = A+B+C - A∩B - B∩C - C∩A + A∩B∩C</li>
</ul>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> LL n,sum;</span><br><span class="line"> <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n)!=EOF)</span><br><span class="line"> &#123;</span><br><span class="line">    sum=n/<span class="number">2</span>+n/<span class="number">5</span>+n/<span class="number">11</span>+n/<span class="number">13</span>;</span><br><span class="line">    LL cnt=sum-n/<span class="number">10</span>-n/<span class="number">22</span>-n/<span class="number">26</span>-n/<span class="number">55</span>-n/<span class="number">65</span>-n/<span class="number">143</span>+n/<span class="number">110</span>+n/<span class="number">130</span>+n/<span class="number">286</span>+n/<span class="number">715</span>-n/<span class="number">1430</span>;</span><br><span class="line">    LL ans=n-cnt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 题解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[欢迎来到Armin的博客]]></title>
      <url>/Welcome/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>欢迎来到Armin的博客，其他内容还在持续搭建（xjb摸索）中。<br><a id="more"></a></p>
<hr>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="测试flash插件"><a href="#测试flash插件" class="headerlink" title="测试flash插件"></a>测试flash插件</h2><embed src="//music.163.com/style/swf/widget.swf?sid=5310505&type=2&auto=1&width=320&height=66" width="340" height="86" allownetworking="all">

<h2 id="测试插入代码"><a href="#测试插入代码" class="headerlink" title="测试插入代码"></a>测试插入代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello world!"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//测试注释</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试链接"><a href="#测试链接" class="headerlink" title="测试链接"></a>测试链接</h2><p><a href="https://paste.ubuntu.com/" target="_blank" rel="noopener">分享代码</a></p>
<h2 id="测试公式"><a href="#测试公式" class="headerlink" title="测试公式"></a>测试公式</h2><p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>
<script type="math/tex; mode=display">\ sum_{i=1}^n a_i=0</script><script type="math/tex; mode=display">f (x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2</script><script type="math/tex; mode=display">\ sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}</script><h2 id="测试表格"><a href="#测试表格" class="headerlink" title="测试表格"></a>测试表格</h2><div class="table-container">
<table>
<thead>
<tr>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>蒟蒻</td>
<td>59</td>
</tr>
<tr>
<td>神犇</td>
<td>100</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      
        
    </entry>
    
  
  
</search>
